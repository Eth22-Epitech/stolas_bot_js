var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import bestfit from './bestfit';
import { pick, take, without } from './collections';
import { SUPPORTS_WEBP } from './webp-check';
export var getSpecificRendition = function (_a, renditionLabel, isStill, useVideo) {
    var images = _a.images, isSticker = _a.is_sticker;
    if (isStill === void 0) { isStill = false; }
    if (useVideo === void 0) { useVideo = false; }
    if (!images || !renditionLabel)
        return '';
    isStill = isStill && !useVideo;
    // @ts-ignore come back to this
    var rendition = images["".concat(renditionLabel).concat(isStill ? '_still' : '')];
    if (rendition) {
        if (isSticker || isStill) {
            return rendition.url;
        }
        var webP = SUPPORTS_WEBP && rendition.webp;
        return useVideo ? rendition.mp4 : webP || rendition.url;
    }
    return '';
};
export var getBestVideo = function (video, width, height) {
    var assets = video === null || video === void 0 ? void 0 : video.assets;
    if (assets) {
        assets = __assign({}, assets);
        // @ts-ignore we don't show source according to the existing code
        delete assets.source;
        var filteredAssets = Object.values(assets).sort(function (a, b) { return a.width - b.width; });
        return bestfit(filteredAssets, width, height);
    }
};
var getRenditions = function (type, images, video) {
    return type === 'video' && video && video.previews && !Object.keys(images).length ? video.previews : images;
};
export var getBestRendition = function (images, gifWidth, gifHeight, scaleUpMaxPixels) {
    var checkRenditions = pick(images, [
        'original',
        'fixed_width',
        'fixed_height',
        'fixed_width_small',
        'fixed_height_small',
    ]);
    var testImages = Object.entries(checkRenditions).map(function (_a) {
        var renditionName = _a[0], val = _a[1];
        return (__assign({ renditionName: renditionName }, val));
    });
    return bestfit(testImages, gifWidth, gifHeight, scaleUpMaxPixels);
};
export var getBestRenditionUrl = function (_a, gifWidth, gifHeight, options) {
    var images = _a.images, video = _a.video, type = _a.type;
    if (options === void 0) { options = { isStill: false, useVideo: false }; }
    if (!gifWidth || !gifHeight || !images)
        return '';
    var useVideo = options.useVideo, isStill = options.isStill, scaleUpMaxPixels = options.scaleUpMaxPixels;
    var renditions = getRenditions(type, images, video);
    var renditionName = getBestRendition(renditions, gifWidth, gifHeight, scaleUpMaxPixels).renditionName;
    // still, video, webp or gif
    var key = "".concat(renditionName).concat(isStill && !useVideo ? '_still' : '');
    var rendition = renditions[key];
    var match = useVideo ? rendition.mp4 : SUPPORTS_WEBP && rendition.webp ? rendition.webp : rendition.url;
    return (match || '');
};
export var getGifHeight = function (_a, gifWidth) {
    var images = _a.images;
    var fixed_width = images.fixed_width;
    if (fixed_width) {
        var width = fixed_width.width, height = fixed_width.height;
        var aspectRatio = width / height;
        return Math.round(gifWidth / aspectRatio);
    }
    return 0;
};
export var getGifWidth = function (_a, gifHeight) {
    var images = _a.images;
    var fixed_width = images.fixed_width;
    if (fixed_width) {
        var width = fixed_width.width, height = fixed_width.height;
        var aspectRatio = width / height;
        return Math.round(gifHeight * aspectRatio);
    }
    return 0;
};
/**
 * GIF Text - Alt Text: Generates alt text for
 * GIF images based on username and tags.
 * @prop  {Gif}
 * @return {String} GIF alt text.
 */
export var getAltText = function (_a) {
    var alt_text = _a.alt_text, user = _a.user, _b = _a.tags, tags = _b === void 0 ? [] : _b, _c = _a.is_sticker, is_sticker = _c === void 0 ? false : _c, _d = _a.title, title = _d === void 0 ? '' : _d;
    if (alt_text) {
        return alt_text;
    }
    if (title) {
        return title;
    }
    var username = (user && user.username) || '';
    var filteredTags = take(without(tags, ['transparent']), username ? 4 : 5);
    return "".concat(username ? "".concat(username, " ") : "").concat(filteredTags.join(' '), " ").concat(is_sticker ? 'Sticker' : 'GIF');
};
//# sourceMappingURL=gif-utils.js.map